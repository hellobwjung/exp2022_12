/*
 * day10_EX_8퍼즐A_user_STL_ver1_1.cpp
 *
 *  Created on: 2022. 12. 16.
 *      Author: bw
 */

extern void move(int mode);

#include <cstdio>
#include <algorithm>
#include <unordered_map>
using namespace std;

#define rint register int

const int LM = 181440;
struct Data {
  int face, zeroPos, pathIdx, pathDir;
} que[LM + 5];
int fr, re;
unordered_map<int, int> hmap; // int:face, int: que's index
//////////////////////////////// hmap[face]= index
// 0이, 0~8위치에 있을, 상하좌우 인접한 위치, max4개까지 가

int adj[9][5] = { { 1, 3 }, { 0, 2, 4 }, { 1, 5 }, { 0, 4, 6 }, { 1, 3, 5, 7 },
    { 2, 4, 8 }, { 3, 7 }, { 4, 6, 8 }, { 5, 7 } };

// 0이 0~8위치에 있을 때, 상하좌우로 가는 방
int dir[9][5] = { { 3, 1 }, { 2, 3, 1 }, { 2, 1 }, { 0, 3, 1 }, { 0, 2, 3, 1 },
    { 0, 2, 1 }, { 0, 3 }, { 0, 2, 3 }, { 0, 2 } };

//             123,456,780  23,456,780  3,456,780  456,780  56,789  6,780  789
int dec[9] = { 100'000'000, 10'000'000, 1'000'000, 100'000, 10'000, 1'000, 100,
//  80  0
    10, 1 };

inline void insert(int key, int val) {
  hmap[key] = val;
}
void BFS() {
  que[re++] = { 123456780, 8, 0, 0 }; // face, zeroPos, pathIdx, pathDir
  const int key = 123456780, val = 0;
  hmap[key] = val;
  while (fr < re) {
    Data t = que[fr];
    int i = 0;
    do {
      const int newZeros = adj[t.zeroPos][i];
      int val = t.face / dec[newZeros]; //0이 이동할 위치에 있는 1~8의 숫자.
      // 0 을 이동시키
      int newFace = t.face - val * dec[newZeros] + val * dec[t.zeroPos];
      if (hmap.count(newFace) == 0) { // newFace가 이전에 만들어진 적이 없는지 확인,
        hmap[newFace] = re; // 새롭게 만들어진 수라면, 

      }

      i++;
    } while (1);
  }

}

void test(const int puzzle[3][3]) {

  if (re == 0) {
    BFS();
  }

  int y, x, face = 0;
  for (y = 0; y < 3; y++) {
    for (x = 0; x < 3; x++) {
      face = face * 10 + puzzle[y][x];

    }

    int idx = hmap[face];
    while (idx) {
      move(que[idx].pathDir);
      idx = que[idx].pathIdx;

    }

  }
}
